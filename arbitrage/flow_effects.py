"""
Flow Effects Trading Strategy

Based on monthly boundary condition patterns that exploit calendar-based
market inefficiencies. Original strategy achieved 472% returns on TLT.

Adapted for:
1. Polymarket crypto hourly up/down markets
2. Direct crypto trading (staged)

Key signals:
- SHORT: 1st and 5th of each month (selling pressure, rebalancing)
- LONG: 7 days and 1 day before month-end (window dressing, momentum)
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Dict, List, Optional, Tuple
import calendar
import json
from pathlib import Path
import httpx


class FlowSignal(Enum):
    """Flow effect signal types."""
    LONG = "long"
    SHORT = "short"
    NEUTRAL = "neutral"


@dataclass
class FlowSignalResult:
    """Result of flow signal calculation."""
    signal: FlowSignal
    reason: str
    strength: float  # 0-1
    days_until_change: int
    timestamp: datetime


@dataclass
class FlowTrade:
    """A trade generated by flow effects."""
    signal: FlowSignal
    asset: str
    entry_time: datetime
    entry_price: float
    size_usd: float
    target_exit_time: datetime
    actual_exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    pnl: float = 0.0
    status: str = "open"  # open, closed, cancelled


class FlowEffectsStrategy:
    """
    Monthly flow effects trading strategy.

    Calendar Signals:
    - Day 1: SHORT (month-start selling, profit-taking)
    - Day 5: SHORT (weekly rebalancing)
    - Day -7 (7 before month-end): LONG (window dressing begins)
    - Day -1 (last day): LONG (month-end buying pressure)

    For Polymarket crypto markets:
    - LONG signal -> Buy YES on "BTC Up" / Buy NO on "BTC Down"
    - SHORT signal -> Buy YES on "BTC Down" / Buy NO on "BTC Up"
    """

    # Signal days (negative = days before month end)
    SHORT_DAYS = [1, 5]
    LONG_DAYS_BEFORE_END = [7, 1]  # 7 days before end, 1 day before end

    # Signal strength by day
    SIGNAL_STRENGTH = {
        1: 0.8,   # Month start - strong
        5: 0.6,   # Mid-week - moderate
        -7: 0.7,  # Week before end - moderate-strong
        -1: 0.9,  # Last day - very strong
    }

    def __init__(self, state_file: str = "flow_effects_state.json"):
        self.state_file = Path(state_file)
        self.trades: List[FlowTrade] = []
        self.current_signal: Optional[FlowSignalResult] = None
        self._load_state()

    def _load_state(self):
        """Load previous state."""
        if self.state_file.exists():
            try:
                with open(self.state_file, 'r') as f:
                    data = json.load(f)
                    for trade_data in data.get("trades", []):
                        trade_data["signal"] = FlowSignal(trade_data["signal"])
                        trade_data["entry_time"] = datetime.fromisoformat(trade_data["entry_time"])
                        trade_data["target_exit_time"] = datetime.fromisoformat(trade_data["target_exit_time"])
                        if trade_data.get("actual_exit_time"):
                            trade_data["actual_exit_time"] = datetime.fromisoformat(trade_data["actual_exit_time"])
                        self.trades.append(FlowTrade(**trade_data))
                print(f"[FlowEffects] Loaded {len(self.trades)} trades from state")
            except Exception as e:
                print(f"[FlowEffects] Error loading state: {e}")

    def _save_state(self):
        """Save current state."""
        data = {
            "last_updated": datetime.now(timezone.utc).isoformat(),
            "trades": [
                {
                    "signal": t.signal.value,
                    "asset": t.asset,
                    "entry_time": t.entry_time.isoformat(),
                    "entry_price": t.entry_price,
                    "size_usd": t.size_usd,
                    "target_exit_time": t.target_exit_time.isoformat(),
                    "actual_exit_time": t.actual_exit_time.isoformat() if t.actual_exit_time else None,
                    "exit_price": t.exit_price,
                    "pnl": t.pnl,
                    "status": t.status,
                }
                for t in self.trades
            ],
            "statistics": self.get_statistics(),
        }
        with open(self.state_file, 'w') as f:
            json.dump(data, f, indent=2)

    def get_days_until_month_end(self, dt: datetime) -> int:
        """Get number of days until end of month."""
        _, last_day = calendar.monthrange(dt.year, dt.month)
        return last_day - dt.day

    def get_flow_signal(self, dt: Optional[datetime] = None) -> FlowSignalResult:
        """
        Calculate the current flow signal based on date.

        Args:
            dt: Date to check (defaults to now)

        Returns:
            FlowSignalResult with signal, reason, and strength
        """
        if dt is None:
            dt = datetime.now(timezone.utc)

        day_of_month = dt.day
        days_until_end = self.get_days_until_month_end(dt)
        _, last_day = calendar.monthrange(dt.year, dt.month)

        # Check SHORT signals (day 1 and 5)
        if day_of_month in self.SHORT_DAYS:
            strength = self.SIGNAL_STRENGTH.get(day_of_month, 0.5)
            if day_of_month == 1:
                reason = "Month start - institutional rebalancing and profit-taking"
                days_until_change = 5 - day_of_month  # Until next signal
            else:  # day 5
                reason = "Day 5 - weekly rebalancing pressure"
                days_until_change = (last_day - 7) - day_of_month  # Until long signal

            return FlowSignalResult(
                signal=FlowSignal.SHORT,
                reason=reason,
                strength=strength,
                days_until_change=max(1, days_until_change),
                timestamp=dt,
            )

        # Check LONG signals (7 days and 1 day before end)
        if days_until_end in self.LONG_DAYS_BEFORE_END:
            strength = self.SIGNAL_STRENGTH.get(-days_until_end, 0.5)
            if days_until_end == 7:
                reason = "T-7 days - window dressing begins, institutional buying"
                days_until_change = 6  # Until stronger signal
            else:  # 1 day before end
                reason = "Last day of month - peak buying pressure"
                days_until_change = 1  # Signal ends tomorrow

            return FlowSignalResult(
                signal=FlowSignal.LONG,
                reason=reason,
                strength=strength,
                days_until_change=days_until_change,
                timestamp=dt,
            )

        # Check if we're in the "long zone" (last 7 days)
        if days_until_end <= 7:
            return FlowSignalResult(
                signal=FlowSignal.LONG,
                reason=f"Month-end zone - {days_until_end} days until end",
                strength=0.5 + (7 - days_until_end) * 0.05,  # Increases as we approach end
                days_until_change=days_until_end,
                timestamp=dt,
            )

        # Neutral zone
        if day_of_month < 5:
            days_until_change = 5 - day_of_month
        elif day_of_month <= last_day - 7:
            days_until_change = (last_day - 7) - day_of_month
        else:
            days_until_change = 1

        return FlowSignalResult(
            signal=FlowSignal.NEUTRAL,
            reason=f"Neutral zone - day {day_of_month} of {last_day}",
            strength=0.0,
            days_until_change=max(1, days_until_change),
            timestamp=dt,
        )

    def get_signal_schedule(self, year: int, month: int) -> List[Tuple[int, FlowSignal, str]]:
        """Get the signal schedule for a given month."""
        _, last_day = calendar.monthrange(year, month)
        schedule = []

        for day in range(1, last_day + 1):
            dt = datetime(year, month, day, tzinfo=timezone.utc)
            signal = self.get_flow_signal(dt)
            if signal.signal != FlowSignal.NEUTRAL:
                schedule.append((day, signal.signal, signal.reason))

        return schedule

    def get_polymarket_action(self, signal: FlowSignal) -> Dict[str, str]:
        """
        Convert flow signal to Polymarket action.

        For BTC hourly up/down markets:
        - LONG -> Expect BTC to go up -> Buy YES on "Up" market
        - SHORT -> Expect BTC to go down -> Buy YES on "Down" market
        """
        if signal == FlowSignal.LONG:
            return {
                "btc_up_market": "BUY_YES",
                "btc_down_market": "BUY_NO",
                "eth_up_market": "BUY_YES",
                "eth_down_market": "BUY_NO",
                "rationale": "Flow effects indicate bullish pressure",
            }
        elif signal == FlowSignal.SHORT:
            return {
                "btc_up_market": "BUY_NO",
                "btc_down_market": "BUY_YES",
                "eth_up_market": "BUY_NO",
                "eth_down_market": "BUY_YES",
                "rationale": "Flow effects indicate bearish pressure",
            }
        else:
            return {
                "btc_up_market": "HOLD",
                "btc_down_market": "HOLD",
                "eth_up_market": "HOLD",
                "eth_down_market": "HOLD",
                "rationale": "Neutral zone - no flow signal",
            }

    def get_crypto_action(self, signal: FlowSignal) -> Dict[str, str]:
        """
        Convert flow signal to direct crypto trading action.

        For spot/futures trading:
        - LONG -> Buy BTC/ETH
        - SHORT -> Sell/Short BTC/ETH
        """
        if signal == FlowSignal.LONG:
            return {
                "btc": "LONG",
                "eth": "LONG",
                "position_size": "normal",
                "leverage": "1x-2x",
                "rationale": "Month-end buying pressure expected",
            }
        elif signal == FlowSignal.SHORT:
            return {
                "btc": "SHORT",
                "eth": "SHORT",
                "position_size": "reduced",  # Shorting is riskier
                "leverage": "1x",
                "rationale": "Month-start/rebalancing selling expected",
            }
        else:
            return {
                "btc": "HOLD",
                "eth": "HOLD",
                "position_size": "none",
                "leverage": "none",
                "rationale": "Neutral - wait for signal",
            }

    def record_trade(
        self,
        signal: FlowSignal,
        asset: str,
        entry_price: float,
        size_usd: float,
        hold_days: int = 1,
    ) -> FlowTrade:
        """Record a new trade."""
        now = datetime.now(timezone.utc)
        trade = FlowTrade(
            signal=signal,
            asset=asset,
            entry_time=now,
            entry_price=entry_price,
            size_usd=size_usd,
            target_exit_time=now + timedelta(days=hold_days),
        )
        self.trades.append(trade)
        self._save_state()
        return trade

    def close_trade(self, trade: FlowTrade, exit_price: float):
        """Close a trade and calculate PnL."""
        trade.actual_exit_time = datetime.now(timezone.utc)
        trade.exit_price = exit_price
        trade.status = "closed"

        # Calculate PnL
        if trade.signal == FlowSignal.LONG:
            # Long: profit if price went up
            trade.pnl = (exit_price - trade.entry_price) / trade.entry_price * trade.size_usd
        else:
            # Short: profit if price went down
            trade.pnl = (trade.entry_price - exit_price) / trade.entry_price * trade.size_usd

        self._save_state()
        return trade

    def get_open_trades(self) -> List[FlowTrade]:
        """Get all open trades."""
        return [t for t in self.trades if t.status == "open"]

    def get_statistics(self) -> dict:
        """Get trading statistics."""
        closed_trades = [t for t in self.trades if t.status == "closed"]

        if not closed_trades:
            return {
                "total_trades": len(self.trades),
                "closed_trades": 0,
                "open_trades": len(self.get_open_trades()),
                "total_pnl": 0,
                "win_rate": 0,
                "avg_pnl": 0,
            }

        wins = [t for t in closed_trades if t.pnl > 0]
        losses = [t for t in closed_trades if t.pnl <= 0]
        total_pnl = sum(t.pnl for t in closed_trades)

        return {
            "total_trades": len(self.trades),
            "closed_trades": len(closed_trades),
            "open_trades": len(self.get_open_trades()),
            "wins": len(wins),
            "losses": len(losses),
            "win_rate": len(wins) / len(closed_trades) * 100 if closed_trades else 0,
            "total_pnl": total_pnl,
            "avg_pnl": total_pnl / len(closed_trades) if closed_trades else 0,
            "best_trade": max(t.pnl for t in closed_trades) if closed_trades else 0,
            "worst_trade": min(t.pnl for t in closed_trades) if closed_trades else 0,
        }

    def print_status(self):
        """Print current strategy status."""
        signal = self.get_flow_signal()
        stats = self.get_statistics()

        print()
        print("=" * 60)
        print("FLOW EFFECTS STRATEGY STATUS")
        print("=" * 60)
        print(f"Current Signal: {signal.signal.value.upper()}")
        print(f"Reason: {signal.reason}")
        print(f"Strength: {signal.strength:.0%}")
        print(f"Days until change: {signal.days_until_change}")
        print()

        poly_action = self.get_polymarket_action(signal.signal)
        print("Polymarket Actions:")
        print(f"  BTC Up Market: {poly_action['btc_up_market']}")
        print(f"  BTC Down Market: {poly_action['btc_down_market']}")
        print()

        crypto_action = self.get_crypto_action(signal.signal)
        print("Crypto Actions:")
        print(f"  BTC: {crypto_action['btc']}")
        print(f"  ETH: {crypto_action['eth']}")
        print()

        print("Statistics:")
        print(f"  Total Trades: {stats['total_trades']}")
        print(f"  Win Rate: {stats['win_rate']:.0f}%")
        print(f"  Total PnL: ${stats['total_pnl']:.2f}")
        print("=" * 60)


class PolymarketFlowTrader:
    """
    Execute flow effects strategy on Polymarket crypto markets.
    """

    GAMMA_API = "https://gamma-api.polymarket.com"

    def __init__(
        self,
        strategy: Optional[FlowEffectsStrategy] = None,
        max_position_usd: float = 100,
        dry_run: bool = True,
    ):
        self.strategy = strategy or FlowEffectsStrategy()
        self.max_position_usd = max_position_usd
        self.dry_run = dry_run
        self.active_positions: Dict[str, dict] = {}

    async def find_crypto_hourly_markets(self) -> List[dict]:
        """Find active BTC/ETH hourly up/down markets."""
        async with httpx.AsyncClient(timeout=30) as client:
            try:
                resp = await client.get(
                    f"{self.GAMMA_API}/markets",
                    params={"closed": "false", "limit": 200}
                )
                if resp.status_code != 200:
                    return []

                markets = resp.json()
                crypto_markets = []

                for m in markets:
                    question = m.get("question", "").lower()
                    # Look for hourly crypto markets
                    if any(term in question for term in ["bitcoin", "btc", "ethereum", "eth"]):
                        if any(term in question for term in ["up", "down", "above", "below", "hour"]):
                            crypto_markets.append({
                                "condition_id": m.get("conditionId"),
                                "question": m.get("question"),
                                "slug": m.get("slug"),
                                "end_date": m.get("endDate"),
                                "tokens": m.get("tokens", []),
                                "is_up_market": "up" in question or "above" in question,
                            })

                return crypto_markets

            except Exception as e:
                print(f"[FlowTrader] Error fetching markets: {e}")
                return []

    async def execute_signal(self) -> List[dict]:
        """Execute current flow signal on Polymarket."""
        signal = self.strategy.get_flow_signal()

        if signal.signal == FlowSignal.NEUTRAL:
            print("[FlowTrader] Neutral signal - no trades")
            return []

        markets = await self.find_crypto_hourly_markets()
        if not markets:
            print("[FlowTrader] No crypto hourly markets found")
            return []

        actions = self.strategy.get_polymarket_action(signal.signal)
        trades_executed = []

        for market in markets[:4]:  # Limit to 4 markets
            is_up = market["is_up_market"]

            if is_up:
                action = actions["btc_up_market"]
            else:
                action = actions["btc_down_market"]

            if action == "HOLD":
                continue

            # Determine which token to buy
            tokens = market.get("tokens", [])
            yes_token = next((t for t in tokens if t.get("outcome") == "Yes"), None)
            no_token = next((t for t in tokens if t.get("outcome") == "No"), None)

            if action == "BUY_YES" and yes_token:
                target_token = yes_token
                side = "YES"
            elif action == "BUY_NO" and no_token:
                target_token = no_token
                side = "NO"
            else:
                continue

            price = float(target_token.get("price", 0.5))
            size = min(self.max_position_usd, self.max_position_usd * signal.strength)

            trade_info = {
                "market": market["question"][:60],
                "condition_id": market["condition_id"],
                "side": side,
                "action": action,
                "price": price,
                "size_usd": size,
                "signal": signal.signal.value,
                "signal_strength": signal.strength,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

            if self.dry_run:
                print(f"[DRY RUN] {action} on {market['question'][:50]}")
                print(f"          Side: {side} @ ${price:.2f}, Size: ${size:.2f}")
            else:
                print(f"[LIVE] {action} on {market['question'][:50]}")
                # TODO: Execute actual trade via py-clob-client

            trades_executed.append(trade_info)

            # Record in strategy
            self.strategy.record_trade(
                signal=signal.signal,
                asset=market["condition_id"],
                entry_price=price,
                size_usd=size,
                hold_days=signal.days_until_change,
            )

        return trades_executed

    async def run(self, check_interval: int = 3600):
        """Run the flow effects trader."""
        print("=" * 60)
        print("FLOW EFFECTS POLYMARKET TRADER")
        print("=" * 60)
        print(f"Mode: {'DRY RUN' if self.dry_run else 'LIVE'}")
        print(f"Max position: ${self.max_position_usd}")
        print(f"Check interval: {check_interval}s")
        print("=" * 60)

        self.strategy.print_status()

        last_signal = None

        while True:
            try:
                signal = self.strategy.get_flow_signal()

                # Only trade on signal changes or at signal days
                if signal.signal != FlowSignal.NEUTRAL:
                    if last_signal != signal.signal:
                        print(f"\n[FlowTrader] Signal changed: {signal.signal.value.upper()}")
                        trades = await self.execute_signal()
                        print(f"[FlowTrader] Executed {len(trades)} trades")

                last_signal = signal.signal

                # Print status periodically
                now = datetime.now(timezone.utc)
                if now.hour == 0 and now.minute < 5:  # Daily at midnight
                    self.strategy.print_status()

            except KeyboardInterrupt:
                print("\n[FlowTrader] Stopping...")
                break
            except Exception as e:
                print(f"[FlowTrader] Error: {e}")

            await asyncio.sleep(check_interval)

        self.strategy.print_status()


# Crypto trading interface (staged for future use)
class CryptoFlowTrader:
    """
    Direct crypto trading using flow effects.
    Staged for use with exchanges like Binance, Coinbase, etc.
    """

    def __init__(
        self,
        strategy: Optional[FlowEffectsStrategy] = None,
        exchange: str = "binance",
        api_key: Optional[str] = None,
        api_secret: Optional[str] = None,
    ):
        self.strategy = strategy or FlowEffectsStrategy()
        self.exchange = exchange
        self.api_key = api_key
        self.api_secret = api_secret

        # Staged - not connected yet
        self.connected = False

    def get_current_recommendation(self) -> dict:
        """Get current trading recommendation."""
        signal = self.strategy.get_flow_signal()
        action = self.strategy.get_crypto_action(signal.signal)

        return {
            "signal": signal.signal.value,
            "strength": signal.strength,
            "reason": signal.reason,
            "btc_action": action["btc"],
            "eth_action": action["eth"],
            "suggested_leverage": action["leverage"],
            "days_until_change": signal.days_until_change,
        }

    def print_recommendation(self):
        """Print current recommendation."""
        rec = self.get_current_recommendation()

        print()
        print("=" * 60)
        print("CRYPTO FLOW EFFECTS RECOMMENDATION")
        print("=" * 60)
        print(f"Signal: {rec['signal'].upper()} (Strength: {rec['strength']:.0%})")
        print(f"Reason: {rec['reason']}")
        print()
        print(f"BTC: {rec['btc_action']}")
        print(f"ETH: {rec['eth_action']}")
        print(f"Suggested Leverage: {rec['suggested_leverage']}")
        print(f"Hold for: ~{rec['days_until_change']} days")
        print("=" * 60)
        print()
        print("NOTE: Direct crypto trading not yet connected.")
        print("Use this recommendation manually or integrate with exchange API.")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Flow Effects Trading Strategy")
    parser.add_argument("--mode", choices=["status", "polymarket", "crypto", "schedule"],
                        default="status", help="Run mode")
    parser.add_argument("--live", action="store_true", help="Enable live trading")
    parser.add_argument("--max-pos", type=float, default=100, help="Max position size")

    args = parser.parse_args()

    strategy = FlowEffectsStrategy()

    if args.mode == "status":
        strategy.print_status()

    elif args.mode == "schedule":
        now = datetime.now(timezone.utc)
        print(f"\nFlow Effects Schedule for {now.strftime('%B %Y')}:")
        print("-" * 50)
        schedule = strategy.get_signal_schedule(now.year, now.month)
        for day, signal, reason in schedule:
            print(f"  Day {day:2d}: {signal.value.upper():6s} - {reason[:40]}")

    elif args.mode == "polymarket":
        trader = PolymarketFlowTrader(
            strategy=strategy,
            max_position_usd=args.max_pos,
            dry_run=not args.live,
        )
        asyncio.run(trader.run())

    elif args.mode == "crypto":
        trader = CryptoFlowTrader(strategy=strategy)
        trader.print_recommendation()
